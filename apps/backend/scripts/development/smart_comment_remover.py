#!/usr/bin/env python3
"""Smart Comment Remover - Multi-language intelligent comment cleanup.

Removes obvious and redundant comments while preserving valuable documentation
and important explanations across Python, JavaScript, TypeScript, and Vue files.
"""

import argparse
import re
import sys
from pathlib import Path


class CommentAnalyzer:
    """Analyzes comments to determine if they should be kept or removed."""

    # Patterns that indicate important comments to ALWAYS keep
    KEEP_PATTERNS = {
        "copyright_license": r"(copyright|license|author|@license|@copyright)",
        "warnings": r"(warning|fixme|hack|todo|note|bug|issue)",
        "api_docs": r"(@param|@return|@raises|@type|Args:|Returns:|Raises:|Example:)",
        "external_refs": r"(https?://|see:|reference:|spec:|rfc\d+)",
        "django_generated": r"Generated by Django",
        "complex_logic": r"(algorithm|complexity|performance|optimization|edge case)",
        "business_logic": r"(business|requirement|compliance|regulation|policy)",
        "configuration": r"(config|setting|environment|production|staging)",
        "security": r"(security|auth|permission|csrf|xss|sql injection)",
    }

    # Patterns that indicate obvious/redundant comments to REMOVE
    REMOVE_PATTERNS = {
        "obvious_assignment": r"^(set|assign|initialize|create)\s+\w+\s*(to|=)",
        "obvious_increment": r"^(increment|decrement)\s+\w+",
        "obvious_loop": r"^(loop|iterate)\s+(through|over|for)",
        "obvious_return": r"^return\s+\w+",
        "obvious_import": r"^import\s+\w+",
        "obvious_call": r"^call\s+\w+",
        "debug_temp": r"(debug|temp|temporary|testing|test\s+code)",
        "single_word": r"^\s*[#/]\s*\w+\s*$",  # Single word comments
        "deprecated_replacements": r"(replaces deprecated|deprecated.*replaced|instead of deprecated)",
        "old_version_refs": r"(old version|previous version|legacy.*removed|no longer.*)",
        "obvious_crud": r"(save|delete|update|create|add|remove)\s+(the|this|that)\s+\w+",
        "obvious_getset": r"(get|set|return)\s+(the|this|that)\s+\w+",
        "obvious_check": r"(check|verify|validate)\s+(if|that|the)",
        "end_markers": r"(end of|end\s+\w+|close\s+\w+)$",
        "useless_state": r"^(done|finished|complete|ready|ok)[\s\.\-]*$",
        "obvious_condition": r"(if\s+\w+|when\s+\w+|unless\s+\w+)\s+(is|are|has|have)",
        "django_obvious": r"(save the model|create.*object|update.*field|delete.*record)",
        "migration_obvious": r"(add.*field|remove.*field|alter.*table|create.*table)",
        "view_obvious": r"(render.*template|redirect.*to|get.*object|post.*request)",
    }

    def __init__(self, language: str):
        self.language = language
        self.comment_chars = self._get_comment_chars()

    def _get_comment_chars(self) -> dict[str, str]:
        """Get comment syntax for different languages."""
        if self.language == "python":
            return {"single": "#", "multi_start": '"""', "multi_end": '"""'}
        elif self.language in ["javascript", "typescript"]:
            return {"single": "//", "multi_start": "/*", "multi_end": "*/"}
        elif self.language == "vue":
            return {"single": "//", "multi_start": "/*", "multi_end": "*/", "html": "<!--"}
        return {"single": "#"}

    def should_keep_comment(self, comment: str, line_after: str = "") -> tuple[bool, str]:
        """Determine if a comment should be kept.

        Args:
            comment: The comment text
            line_after: The line immediately following the comment

        Returns:
            Tuple of (should_keep, reason)
        """
        comment_lower = comment.lower()

        # Always keep if matches important patterns
        for pattern_name, pattern in self.KEEP_PATTERNS.items():
            if re.search(pattern, comment_lower):
                return True, f"Important: {pattern_name}"

        # Keep long comments (likely have value)
        if len(comment.strip()) > 80:
            return True, "Long comment (likely valuable)"

        # Keep comments with multiple sentences
        if len(re.findall(r"[.!?]+", comment)) > 1:
            return True, "Multiple sentences"

        # Keep docstrings and function descriptions
        if re.match(r'^\s*["\']', comment.strip()):
            return True, "Docstring"

        # Check for obvious redundant patterns
        for pattern_name, pattern in self.REMOVE_PATTERNS.items():
            if re.search(pattern, comment_lower):
                # For some patterns, don't need to double-check
                if pattern_name in [
                    "deprecated_replacements",
                    "old_version_refs",
                    "useless_state",
                    "end_markers",
                    "debug_temp",
                ]:
                    return False, f"Redundant: {pattern_name}"
                # Double-check it's really obvious by comparing with next line
                elif self._is_truly_redundant(comment, line_after):
                    return False, f"Redundant: {pattern_name}"

        # Default to keeping if unsure
        return True, "Default keep (unsure)"

    def _is_truly_redundant(self, comment: str, next_line: str) -> bool:
        """Check if comment is truly redundant by comparing with code."""
        if not next_line:
            return False

        comment_words = set(re.findall(r"\w+", comment.lower()))
        code_words = set(re.findall(r"\w+", next_line.lower()))

        # If comment words are mostly in the code, it's likely redundant
        if comment_words and len(comment_words.intersection(code_words)) / len(comment_words) > 0.7:
            return True

        return False


class SmartCommentRemover:
    """Main class for intelligent comment removal."""

    def __init__(self, dry_run: bool = True):
        self.dry_run = dry_run
        self.stats = {"files_processed": 0, "comments_removed": 0, "comments_kept": 0}

    def detect_language(self, file_path: Path) -> str:
        """Detect programming language from file extension."""
        suffix = file_path.suffix.lower()
        if suffix == ".py":
            return "python"
        elif suffix == ".js":
            return "javascript"
        elif suffix == ".ts":
            return "typescript"
        elif suffix == ".vue":
            return "vue"
        else:
            return "unknown"

    def process_file(self, file_path: Path, show_analysis: bool = False) -> dict[str, int]:
        """Process a single file for comment removal."""
        language = self.detect_language(file_path)
        if language == "unknown":
            return {"removed": 0, "kept": 0}

        analyzer = CommentAnalyzer(language)

        try:
            with open(file_path, encoding="utf-8") as f:
                lines = f.readlines()
        except Exception as e:
            print(f"Error reading {file_path}: {e}")
            return {"removed": 0, "kept": 0}

        new_lines = []
        file_stats = {"removed": 0, "kept": 0}

        i = 0
        while i < len(lines):
            line = lines[i]

            # Skip empty lines and non-comment lines
            if not self._has_comment(line, language):
                new_lines.append(line)
                i += 1
                continue

            comment_text = self._extract_comment(line, language)
            if not comment_text:
                new_lines.append(line)
                i += 1
                continue

            # Get context for better analysis
            next_line = lines[i + 1] if i + 1 < len(lines) else ""

            should_keep, reason = analyzer.should_keep_comment(comment_text, next_line)

            if show_analysis:
                print(f"Line {i + 1}: {'KEEP' if should_keep else 'REMOVE'} - {reason}")
                print(f"  Comment: {comment_text.strip()}")

            if should_keep:
                new_lines.append(line)
                file_stats["kept"] += 1
            else:
                # Check if the line has code after the comment
                code_part = self._extract_code_before_comment(line, language)
                if code_part.strip():
                    new_lines.append(code_part.rstrip() + "\n")
                # else: skip the entire line (comment-only line)
                file_stats["removed"] += 1

            i += 1

        # Write the processed file
        if not self.dry_run and file_stats["removed"] > 0:
            try:
                with open(file_path, "w", encoding="utf-8") as f:
                    f.writelines(new_lines)
                print(f"‚úÖ Processed {file_path}: {file_stats['removed']} removed, {file_stats['kept']} kept")
            except Exception as e:
                print(f"‚ùå Error writing {file_path}: {e}")
        elif file_stats["removed"] > 0:
            print(f"üîç DRY RUN {file_path}: {file_stats['removed']} would be removed, {file_stats['kept']} kept")

        return file_stats

    def _has_comment(self, line: str, language: str) -> bool:
        """Check if line contains a comment."""
        if language == "python":
            return "#" in line
        elif language in ["javascript", "typescript", "vue"]:
            return "//" in line or "/*" in line
        return False

    def _extract_comment(self, line: str, language: str) -> str:
        """Extract comment text from a line."""
        if language == "python":
            if "#" in line:
                return line[line.find("#") + 1 :].strip()
        elif language in ["javascript", "typescript", "vue"]:
            if "//" in line:
                return line[line.find("//") + 2 :].strip()
            elif "/*" in line:
                # Simple single-line /* */ comment
                start = line.find("/*")
                end = line.find("*/", start)
                if end != -1:
                    return line[start + 2 : end].strip()
        return ""

    def _extract_code_before_comment(self, line: str, language: str) -> str:
        """Extract code part before comment."""
        if language == "python":
            if "#" in line:
                return line[: line.find("#")]
        elif language in ["javascript", "typescript", "vue"]:
            if "//" in line:
                return line[: line.find("//")]
            elif "/*" in line:
                return line[: line.find("/*")]
        return line

    def process_directory(self, directory: Path, patterns: list[str], show_analysis: bool = False):
        """Process all matching files in a directory."""
        files_found: list[Path] = []

        for pattern in patterns:
            files_found.extend(directory.rglob(pattern))

        if not files_found:
            print(f"No files found matching patterns: {patterns}")
            return

        print(f"Found {len(files_found)} files to process")

        for file_path in sorted(files_found):
            file_stats = self.process_file(file_path, show_analysis)
            self.stats["files_processed"] += 1
            self.stats["comments_removed"] += file_stats["removed"]
            self.stats["comments_kept"] += file_stats["kept"]

    def print_summary(self):
        """Print processing summary."""
        print(f"\n{'=' * 50}")
        print("üìä SUMMARY")
        print("=" * 50)
        print(f"Files processed: {self.stats['files_processed']}")
        print(f"Comments removed: {self.stats['comments_removed']}")
        print(f"Comments kept: {self.stats['comments_kept']}")
        if self.dry_run:
            print("üîç DRY RUN - No files were modified")
        else:
            print("‚úÖ Files have been modified")


def main():
    parser = argparse.ArgumentParser(description="Smart Comment Remover - Intelligently remove redundant comments")
    parser.add_argument("path", help="Directory or file path to process")
    parser.add_argument(
        "--languages",
        choices=["python", "javascript", "typescript", "vue", "all"],
        default="all",
        help="Language(s) to process",
    )
    parser.add_argument("--dry-run", action="store_true", help="Show what would be removed without making changes")
    parser.add_argument("--analysis", action="store_true", help="Show detailed analysis of each comment")
    parser.add_argument("--execute", action="store_true", help="Actually modify files (removes dry-run)")

    args = parser.parse_args()

    path = Path(args.path)
    if not path.exists():
        print(f"‚ùå Path does not exist: {path}")
        sys.exit(1)

    # Determine file patterns to process
    patterns = []
    if args.languages == "all" or args.languages == "python":
        patterns.append("*.py")
    if args.languages == "all" or args.languages == "javascript":
        patterns.append("*.js")
    if args.languages == "all" or args.languages == "typescript":
        patterns.append("*.ts")
    if args.languages == "all" or args.languages == "vue":
        patterns.append("*.vue")

    # Initialize remover
    dry_run = not args.execute
    remover = SmartCommentRemover(dry_run=dry_run)

    print("üöÄ Smart Comment Remover")
    print(f"Path: {path}")
    print(f"Languages: {args.languages}")
    print(f"Mode: {'DRY RUN' if dry_run else 'EXECUTE'}")
    print(f"Patterns: {patterns}")
    print()

    if path.is_file():
        file_stats = remover.process_file(path, args.analysis)
        remover.stats["files_processed"] = 1
        remover.stats["comments_removed"] = file_stats["removed"]
        remover.stats["comments_kept"] = file_stats["kept"]
    else:
        remover.process_directory(path, patterns, args.analysis)

    remover.print_summary()


if __name__ == "__main__":
    main()
